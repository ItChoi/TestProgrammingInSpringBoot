### 상속 관계 매핑
- 관계형 데이터베이스는 상속 관계 X
- 슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 유사
- 상속관계 매핑: 객체의 상속과 구조와 DB의 슈퍼타입 서브타입 관계를 매핑
    <br/>
- 슈퍼타입 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법
    - 각각 테이블로 변환 -> 조인 전략 (테이블을 나누어 관리 -> Item -> Album, Movie, Book)
    - 통합 테이블로 변환 -> 단인 테이블 전략 (하나의 테이블로 관리 Item,Album,Movie,Book)
    - 서브타입 테이블로 변환 -> 구현 클래스마다 테이블 전략 (각 각의 테이블로 관리)
    - 위에 3가지 방식 중 어떤 걸 써더라도 jpa에서는 다 매핑이 가능하다.
    
#### 주요 어노테이션
- @Inheritance(strategy = InheritanceType.XXX)
    - JOINED: 조인 전략
      - 조인 전략이 정석! 단점보다 장점이 더 크다.
      - 장점
        - 테이블 정규화
        - 외래 키 참조 무결성 제약조건 활용 가능
        - 저장공간 효율화
      - 단점
        - 조회 시 조인을 많이 사용, 성능 저하
        - 조회 쿼리가 복잡
        - 데이터 저장 시 INSERT SQL 2번 호출
        
    - SINGLE_TABLE: 단일 테이블 전략 
      - 장점
        - 조인이 필요 없으므로 일반적으로 조회 성능이 빠르다.
        - 조회 쿼리가 단순
      - 단점
        - 자식 엔티티가 매핑한 컬럼은 모두 null 허용 -> 데이터 무결성 입장에서 조금 애매하다.
        - 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있으므로 상황에 따라 조회 성능이 오히려 느려질 수 있다. 
      - @Discriminator 전략이 꼭 들어가야 한다. -> 생략 시에도 필수로 생겨난다. 결론은 운영상 DTYPE이 있는 것이 좋다.
      - 성능상 이점이 있다.
      
    - TABLE_PER_CLASS: 구현 클래스마다 테이블 전략
      - 일단 쓰지 말자.... DB, 객체 패러다임 둘 다 안어울린다.
      - 장점
        - 서브 타입 명확하게 구분해서 처리할 시 효과적
        - not null 제약 조건 사용 가능
      - 단점
        - 여러 자식 테이블 함께 조회 시 성능 느림 (union all) (치명적,,,) 
        - 자식 테이블을 통합해서 쿼리하기 어렵다.
        - 변경이라는 관점에서 되게 안좋다.
        
      - Join 전략과 비슷
      - Item 테이블을 버리고 자식 클래스들을 각각 만든다. Item을 abstract class로 만들고!
      - 값을 단순히 넣고 뺄 땐 좋은데, 언제 망하냐면.... -> 조회 시 문제가 생긴다. -> union all로 다 뒤져서 가져온다.
      
- @DiscriminatorColumn(name = "DTYPE")
    - Dtype 컬럼이 생기고, 자식 엔티티명이 들어가게 된다. 있는 것이 좋은데, 어떤 것 때매 item이 들어왔는지 알 수 있다. name을 통해 DTYPE이 아닌 다른 명칭으로 사용 가능
- @DiscriminatorValue("XXX")
    - 디폹르가 자식 @Entity명 이고, 자식에서 애노테이션 적용하여  명칭을 정한다.
- Item을 extends받은 @Entity인 album, movie, book은 한 테이블에 다 때려박아 진다 Item이란 테이블의 이름으로!
- Join전략 선택 - @Inheritance! -> Item 테이블에 적용
- JPA가 상속관계면 join을 통해 조회를 해준다.
