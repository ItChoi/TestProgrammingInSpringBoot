### JPA (Java Persistence API)
- 자바 진영의 ORM 기준 표준 
- ORM
    - Object-relational mapping
      - 객체는 객체대로 설계, 관계형 데이터베이스는 그에 맞게 설계를 하여 프레임워크가 중간에 이를 매핑
- JPA는 애플리케이션과 JDBC 사이에서 동작
    - JAVA 애플리케이션
      - JPA
        - JDBC API
    - (JDBC API와 DB 사이를 SQL을 통해 결과를 반환한다.)
    - DB
    <br/>
    
    - 설명: Java 애플리케이션 안에 JPA가 있고 개발자가 JPA를 사용 시 JPA가 알아서 JDBC API를 이용하여 DB에 쿼리를 보내고 반환 값을 돌려 받는다.
- JPA 동작 - 저장
    - JVM
      - DAO
      - JPA
        - JDBC API
    - DB
    <br/>
    
    - 설명: MemberDao에서 jpa의 메소드와 함께 Entity Object를 매개변수로 전송하면 JPA에서 Entity 분석, Insert SQL 생성, JDBC API 사용, **패러다임 불일치 해결** 후 JDBC API를 통해 DB에 쿼리를 보내고 결과를 전송받는다.
- JPA 동작 - 조회
    - 위와 같고, JPA에서 ResultSet으로 매핑을 해주고 DAO에 반환해준다.
    
- JPA는 표준 명세
    - 인터페이스의 모음
    - JPA 2.1 표준 명세를 구현한 3가지 구현체
      - 하이버네이트, EclipseLink, DataNucleus
    - 애플리케이션
      - JPA 표준 인터페이스
        - Hibernate
        - EclipseLink
        - DataNucleus
- JPA를 왜 사용해야 하는가?
    - SQL 중심적인 개발에서 객체 중심 개발
    - 생산성
      - 저장: jpa.persist(member)
      - 조회: Member member = jpa.find(memberId)
      - 수정: member.setName("name")
      - 삭제: jpa.remove(member)
    - 유지보수
      - 컬럼 추가 시 객체에 넣어야 되고, 인설트 쿼리에 추가해야되고 등등등 하나의 컬럼 추가로 추가 공수가 늘어난다.
    - 패러다임의 불일치 해결
      - JPA와 상속
        - 객체 상속 & 테이블 관계
      - JPA와 연관관계
        - 조회 저장 시 연관되어있는 데이터를 참조하고 가져올 수 있어서 데이터의 신뢰도가 높다.
      - JPA와 객체 그래프 탐색
        - 지연 로딩이란 기능이 있어서 member.ㅇㅇ 하면 조회 시점에 데이터가 채워지는 기능이 있다. (데이터 있다는 가정 하에)
      - JPA와 비교하기
        - 동일 트랜잭션에서 조회한 엔티티가 같음을 보장한다.
    - 성능
      - 1차 캐시와 동일성(identity) 보장
        - 중간 계층이 있을 시 버퍼링과 캐싱을 할 수 있다.
        - 같은 트랜잭션 안에 같은 엔티티 반환 -> 조회 성능 향상 (실무에서 크게 도움은 안되는 정도)
          - 조회 1시 sql, 똑같은 조회 시 캐시!
          - 우리가 알던 캐시가 아니라, 고객 트래픽 요청이 실행되고 빠져 나갈때, 트랜잭션이 끝나는데 그 사이에서 동일성을 보장, 따라서 짧은 시간의 캐싱! 
      - 트랜잭션을 지원하는 쓰기 지연 (transactional write-behind)
        - 버퍼링 기능을 말한다.
          - e.persist(a) e.persist(b) e.persist(c)
          - 위 세개를 각각 마다 쿼리를 3번 실행하는데, 한 번에 모아서 DB에 보낼 수 있는데, JDBC 배치라는 기능이 있는데 코드가 굉장히 지저분해진다. 그러나 JPA 사용시 옵션 하나만 키면 된다! - 트랜잭션 커밋을 이용! 커밋 시 똑같은 코드가 있따면 하나의 네트워크를 통해!!
      - 지연 로딩 (Lazy Loading)과 즉시 로딩
        - 지연 로딩: 객체가 실제 사용될 때 로딩
        - 즉시 로딩: Join Sql로 한 번에 연관된 객체까지 미리 조회
        - 부모만 사용이 많고 어쩌다 자식을 사용하는 경우 지연 로딩, 같이 가져오는 경우가 많을 땐 즉시 로딩! sql로 관리 시 쿠리도 다시 짜야하지만 JPA는 편리하게 옵션 하나로 제어가 가능하다.
    - 데이터 접근 추상화와 벤더 독립성
    - 표준

- ORM은 객체와 RDB 두 기둥 위에 있는 기술! 둘 다 잘해야 한다.