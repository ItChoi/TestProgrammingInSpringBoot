### 실전 예제 - 3. 다양한 연관관계 매핑

- 배송, 카테고리 추가 - 엔티티
    - 주문과 배송은 1:1 (@OneToOne)
    - 상품과 카테고리는 N:M (@ManyToMany)
    - 회원 1 - N 주문(주문  1 - 1 배송, 주문 1 - N 주문상품) - 주문 상품 N - 1 상품 N - N 카테고리
- 카테고리에서 부모 카테고리가 존재한다. 셀프 조인을 하기 위해 카테고리 안 @ManyToOne @JoinColumn(name="PARENT_ID") parent, @OneToMany(mappedBy="parent") List<Category> child를 만들 수 있다.
- 카테고리에는 여러 아이템이 들어오고, 아이템은 여러 카테고리에 소속될 수 있다.
    - @ManyToMany @JoinTable(name = "CATEGORY_ITEM", joinColumns = @JoinColumn(name="CATEGORY_ID"), inverseJoinColumns = @JoinColumn(name="ITEM_ID") List<Item> items; // 내가 조인하고 반대 쪽이 조인할 애를 지정, 중간 테이블이 있따는 가정    
- N:M 관계는 1:N, N:1로
    - 테이블의 N:M관계는 중간 테이블을 이용하여 1:N, N:1로 수정
    - 실전에서는 중간 테이블이 단순하지 않다.
    - @ManyToMany는 제약: 필드 추가 X, 엔티티 테이블 불일치
    - 실전에서는 @ManyToMany 사용 X
- @JoinColumn
    - name: 매핑할 외래 키 이름
    - referencedColumnName: 외래 키가 참조하는 대상 테이블의 컬럼명
    - foreignKey(DDL): 외래 키 제약 조건 직접 지정, 이 속성은 테이블 생성할 때만 사용
    - unique, nullable, ...: @Column 속성과 같다.
- @ManyToOne 
    - optional: false로 설정하면 연관된 엔티티가 항상 있어야 한다.
    - fetch: 글로벌 패치 전략 설정 (즉시, 지연 로딩 설정?)
    - cascade: 영속성 전이 기능 사용
    - targetEntity: 연관된 엔티티의 타입 정보를 설정, 이 기능은 거의 사용하지 않는다. 컬렉션을 사용해도 제네릭으로 타입 정보를 알 수 있다.
- @OneToMany
    - mappedBy: 연관관계의 주인 필드를 선택
    - fetch: ...
    - cascade: ...
    - targetEntity: ...