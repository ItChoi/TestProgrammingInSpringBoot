### 영속성 컨텍스트 2
- 영속성 컨텍스트의 이점
    - 1차 캐시
      - 엔티티 매니저 == 영속 컨텍스트 (미묘한 차이는 있지만 지금의 이해를 돕기 위해 일단)
      - 비영속 -> 영속이 되었을 때 영속성 컨텍스트에는 1차 캐시에 등록이 된다. (id: 스트링 이름, Entity: 객체)
      - 1차 캐시에서 조회 시 jpa는 영속성 컨텍스트에서 1차 캐시를 먼져 뒤지고, 없을 시 DB 조회
        - 1차 캐시 없을 시 DB 조회 후 Entity를 1차 캐시에 저장하고 반환한다.
      - 큰 도움은 안된다. EntityManager는 DB 트랜잭션 단위로 만들고, 종료 시 영속 컨텍스트는 없어진다. -> 1차 캐시도 날라간다. -> 성능적 장점은 없으나, 비즈니스 로직이 복잡한 경우 쬐끔 도움
      - 성능을 통한 이점 보다는 컨셉에 대한 이점이 있다. -> 객체지향적 사용
    - 동일성 보장
      - == 비교시 true (1차 캐시가 동작하기에 가능)
    - 트랜잭션을 지원하는 쓰기 지연
      - 트랜잭션을 커밋하는 순간에 쿼리를 DB에 보낸다.
      - 영속성 컨텍스트 안에는 "쓰기 지연 SQL 저장소" 라는 공간이 있다.
        - 이 장소에 있던 insert가 commit을 하면 flush가 되면서 실제 DB가 commit
      - jdbc 배치 -> hibernate 설정을 통해 쿼리를 버퍼링?에 모아서 하나의 네트워크로 사용 가능
    - 변경 감지
      - select로 찾아온 후 set을 통해 변경 시 jpa는 알아서 insert를 해준다.
        - JPA는 변경 감지 기능이 있다.
        - JPA는 DB 커밋 시점해 내부족으로 flush() 호출, Entity랑 스냅샷을 비교한다. 1차 캐시 안에는 id, entity, 스냅샷이 있다. 스냅샷은 값을 읽어온 최초 시점의 상태! flush 호출 시 entity와 스냅샷을 비교하여 값이 바뀌었을 때 쓰기지연 SQL 저장소에 update를 만들어주고, DB에 반영해준다.
    - 지연 로딩
    